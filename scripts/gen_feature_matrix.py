#!/usr/bin/env python3
import json, re, sys, pathlib, datetime, os, subprocess

ROOT = pathlib.Path(__file__).resolve().parents[1]
FEATURES_JSON = ROOT / "interfaces" / "features.json"
OUT_MD = ROOT / "docs" / "reference" / "feature_matrix.md"

def github_blob_base() -> str:
    import subprocess, os, re
    env_base = os.getenv("REPO_BLOB_BASE")
    if env_base:
        return env_base.rstrip('/') + '/'
    try:
        remote = subprocess.check_output(["git", "config", "--get", "remote.origin.url"], text=True).strip()
        m = re.search(r"github\.com[:/]{1,2}([^/]+)/([^/.]+)", remote)
        if m:
            owner, repo = m.group(1), m.group(2)
            return f"https://github.com/{owner}/{repo}/blob/main/"
    except Exception:
        pass
    return "https://github.com/t3hw00t/ARW/blob/main/"
TOPICS_RS = ROOT / "crates" / "arw-topics" / "src" / "lib.rs"

def load_features():
    with FEATURES_JSON.open("r", encoding="utf-8") as f:
        return json.load(f)

def parse_topics_rs():
    if not TOPICS_RS.exists():
        return set()
    s = TOPICS_RS.read_text(encoding="utf-8", errors="ignore")
    vals = set(re.findall(r'pub const [A-Z0-9_]+:\s*&str\s*=\s*"([^"]+)";', s))
    return vals

def check_paths_exist(paths):
    missing = []
    for p in paths:
        pp = ROOT / p
        if not pp.exists():
            missing.append(p)
    return missing

def md_escape(s: str) -> str:
    return s.replace("_", "\\_")

def _stable_now_timestamp(paths):
    """Return a stable ISO timestamp based on last commit touching given paths.
    Falls back to REPRO_NOW env or current UTC if git not available.
    """
    try:
        args = ["git", "log", "-1", "--format=%cI", "--"] + [str(p) for p in paths if p]
        ts = subprocess.check_output(args, text=True).strip()
        if ts:
            # Normalize to Z if possible
            return ts.replace("+00:00", "Z")
    except Exception:
        pass
    env_ts = os.getenv("REPRO_NOW")
    if env_ts:
        return env_ts
    return datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat(timespec="seconds").replace("+00:00", "Z")

def render(features_doc, known_topics):
    now = _stable_now_timestamp([FEATURES_JSON])
    out = []
    out.append("---")
    out.append("title: Feature Matrix")
    out.append("---\n")
    out.append("<!-- generated by scripts/gen_feature_matrix.py; do not edit by hand -->")
    out.append(f"\n_Last updated: {now}_\n")
    out.append("# Feature Matrix\n")
    base = github_blob_base()
    out.append(
        f"This page is generated from [interfaces/features.json]({base}interfaces/features.json) "
        "and validated against code (topics and file paths).\n"
    )
    for feat in features_doc.get("features", []):
        name = feat.get("name")
        desc = feat.get("description", "")
        scope = feat.get("scope", {})
        out.append(f"## {name}\n")
        out.append(desc + "\n")
        # Scope/maturity
        tags = []
        tier = feat.get("tier")
        if tier:
            tags.append(tier)
        if scope.get("surface"): tags.append(scope["surface"])
        if scope.get("audience"): tags.append(scope["audience"])
        if scope.get("layer"): tags.append(scope["layer"])
        if scope.get("maturity"): tags.append(scope["maturity"])
        if tags:
            out.append(f"- Scope: {' / '.join(tags)}")
        # Owner / deps (optional)
        owner = feat.get("owner")
        if owner:
            out.append(f"- Owner: {owner}")
        deps = feat.get("deps", [])
        if deps:
            out.append("- Depends on:")
            for d in deps:
                out.append(f"  - {d}")
        # SSoT
        ss = feat.get("ssot", [])
        if ss:
            paths = [s.get("path") for s in ss if s.get("path")]
            out.append("- Single Sources of Truth:")
            for p in paths:
                if p.startswith("docs/"):
                    rel = p[len("docs/"):]
                    out.append(f"  - [{rel}](../{rel})")
                else:
                    out.append(f"  - [{p}]({base}{p})")
        # HTTP
        http = feat.get("http", [])
        if http:
            out.append("- HTTP:")
            for h in http:
                out.append(f"  - `{h.get('method','').upper()} {h.get('path','')}`")
        # Read-models
        rms = feat.get("read_models", [])
        if rms:
            out.append("- Read‑models:")
            for r in rms:
                out.append(f"  - `{r}`")
        # Topics (validate)
        tps = feat.get("topics", [])
        if tps:
            out.append("- Events:")
            for t in tps:
                mark = "" if (t in known_topics or t == "state.read.model.patch") else " ⚠"
                out.append(f"  - `{t}`{mark}")
        # Env vars
        envs = feat.get("env", [])
        if envs:
            out.append("- Env:")
            for e in envs:
                out.append(f"  - `{e}`")
        out.append("")
    return "\n".join(out)

def main():
    try:
        features = load_features()
    except Exception as e:
        print(f"error: cannot read features.json: {e}", file=sys.stderr)
        return 2
    known_topics = parse_topics_rs()
    # Path validation
    all_paths = []
    for f in features.get("features", []):
        for s in f.get("ssot", []):
            p = s.get("path")
            if p:
                all_paths.append(p)
    missing = check_paths_exist(all_paths)
    if missing:
        print("warning: missing SSoT paths:\n  - " + "\n  - ".join(missing), file=sys.stderr)
    OUT_MD.parent.mkdir(parents=True, exist_ok=True)
    OUT_MD.write_text(render(features, known_topics), encoding="utf-8")
    print(f"wrote {OUT_MD}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
