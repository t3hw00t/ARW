#!/usr/bin/env python3
import json
import pathlib
import sys

from doc_utils import (
    ROOT,
    _stable_now_timestamp,
    check_paths_exist,
    github_blob_base,
    metadata_block,
    parse_topics_rs,
    stable_updated_date,
)

FEATURES_JSON = ROOT / "interfaces" / "features.json"
OUT_MD = ROOT / "docs" / "reference" / "feature_matrix.md"

def load_features():
    with FEATURES_JSON.open("r", encoding="utf-8") as f:
        return json.load(f)

def render(features_doc, known_topics):
    timestamp = _stable_now_timestamp([FEATURES_JSON])
    updated = stable_updated_date([FEATURES_JSON])
    out = []
    out.append("---")
    out.append("title: Feature Matrix")
    out.append("---\n")
    out.append(
        f"<!-- generated by scripts/gen_feature_matrix.py; do not edit by hand (source ts: {timestamp}) -->"
    )
    out.append("")
    out.append("# Feature Matrix\n")
    out.extend(
        metadata_block(
            status="Stable",
            doc_type="Reference",
            updated=updated,
            microsummary=[
                "Living inventory of shipped features across kernel and optional packs.",
                "Generated from interfaces/features.json and cross-validated against topic constants and source paths.",
                "Lists scope tags, owners, dependencies, HTTP endpoints, read-models, events, environment knobs, and references.",
                "Regenerate with `just features-gen` whenever feature metadata changes.",
            ],
        )
    )
    base = github_blob_base()
    out.append(
        f"This page is generated from [interfaces/features.json]({base}interfaces/features.json) "
        "and validated against code (topics and file paths).\n"
    )
    for feat in features_doc.get("features", []):
        name = feat.get("name")
        desc = feat.get("description", "")
        scope = feat.get("scope", {})
        out.append(f"## {name}\n")
        out.append(desc + "\n")
        # Scope/maturity
        tags = []
        tier = feat.get("tier")
        if tier:
            tags.append(tier)
        if scope.get("surface"): tags.append(scope["surface"])
        if scope.get("audience"): tags.append(scope["audience"])
        if scope.get("layer"): tags.append(scope["layer"])
        if scope.get("maturity"): tags.append(scope["maturity"])
        if tags:
            out.append(f"- Scope: {' / '.join(tags)}")
        # Owner / deps (optional)
        owner = feat.get("owner")
        if owner:
            out.append(f"- Owner: {owner}")
        deps = feat.get("deps", [])
        if deps:
            out.append("- Depends on:")
            for d in deps:
                out.append(f"  - {d}")
        # SSoT
        ss = feat.get("ssot", [])
        if ss:
            paths = [s.get("path") for s in ss if s.get("path")]
            out.append("- Single Sources of Truth:")
            for p in paths:
                if p.startswith("docs/"):
                    rel = p[len("docs/"):]
                    out.append(f"  - [{rel}](../{rel})")
                else:
                    out.append(f"  - [{p}]({base}{p})")
        # HTTP
        http = feat.get("http", [])
        if http:
            out.append("- HTTP:")
            for h in http:
                out.append(f"  - `{h.get('method','').upper()} {h.get('path','')}`")
        # Read-models
        rms = feat.get("read_models", [])
        if rms:
            out.append("- Read‑models:")
            for r in rms:
                out.append(f"  - `{r}`")
        # Topics (validate)
        tps = feat.get("topics", [])
        if tps:
            out.append("- Events:")
            for t in tps:
                mark = "" if (t in known_topics or t == "state.read.model.patch") else " ⚠"
                out.append(f"  - `{t}`{mark}")
        # Env vars
        envs = feat.get("env", [])
        if envs:
            out.append("- Env:")
            for e in envs:
                out.append(f"  - `{e}`")
        refs = feat.get("docs", [])
        if refs:
            out.append("- References:")
            for entry in refs:
                path = entry.get("path") if isinstance(entry, dict) else entry
                if not path:
                    continue
                if path.startswith("docs/"):
                    rel = path[len("docs/"):]
                    out.append(f"  - [{rel}](../{rel})")
                else:
                    out.append(f"  - [{path}]({base}{path})")
        out.append("")
    return "\n".join(out)

def main():
    try:
        features = load_features()
    except Exception as e:
        print(f"error: cannot read features.json: {e}", file=sys.stderr)
        return 2
    known_topics = parse_topics_rs(include_defaults={"state.read.model.patch"})
    # Path validation
    all_paths = []
    for f in features.get("features", []):
        for s in f.get("ssot", []):
            p = s.get("path")
            if p:
                all_paths.append(p)
    missing = check_paths_exist(all_paths)
    if missing:
        print("warning: missing SSoT paths:\n  - " + "\n  - ".join(missing), file=sys.stderr)
    OUT_MD.parent.mkdir(parents=True, exist_ok=True)
    OUT_MD.write_text(render(features, known_topics), encoding="utf-8")
    print(f"wrote {OUT_MD}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
