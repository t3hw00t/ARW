#!/usr/bin/env python3
import json, re, sys, pathlib, datetime

ROOT = pathlib.Path(__file__).resolve().parents[1]
FEATURES_JSON = ROOT / "interfaces" / "features.json"
OUT_MD = ROOT / "docs" / "reference" / "feature_matrix.md"
TOPICS_RS = ROOT / "apps" / "arw-svc" / "src" / "ext" / "topics.rs"

def load_features():
    with FEATURES_JSON.open("r", encoding="utf-8") as f:
        return json.load(f)

def parse_topics_rs():
    if not TOPICS_RS.exists():
        return set()
    s = TOPICS_RS.read_text(encoding="utf-8", errors="ignore")
    vals = set(re.findall(r'pub const [A-Z0-9_]+:\s*&str\s*=\s*"([^"]+)";', s))
    return vals

def check_paths_exist(paths):
    missing = []
    for p in paths:
        pp = ROOT / p
        if not pp.exists():
            missing.append(p)
    return missing

def md_escape(s: str) -> str:
    return s.replace("_", "\\_")

def render(features_doc, known_topics):
    now = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"
    out = []
    out.append("---")
    out.append("title: Feature Matrix")
    out.append("---\n")
    out.append("<!-- generated by scripts/gen_feature_matrix.py; do not edit by hand -->")
    out.append(f"\n_Last updated: {now}_\n")
    out.append("# Feature Matrix\n")
    out.append("This page is generated from `interfaces/features.json` and validated against code (topics and file paths).\n")
    for feat in features_doc.get("features", []):
        name = feat.get("name")
        desc = feat.get("description", "")
        scope = feat.get("scope", {})
        out.append(f"## {name}\n")
        out.append(desc + "\n")
        # Scope/maturity
        tags = []
        if scope.get("surface"): tags.append(scope["surface"]) 
        if scope.get("audience"): tags.append(scope["audience"]) 
        if scope.get("layer"): tags.append(scope["layer"]) 
        if scope.get("maturity"): tags.append(scope["maturity"]) 
        if tags:
            out.append(f"- Scope: {' / '.join(tags)}")
        # Owner / deps (optional)
        owner = feat.get("owner")
        if owner:
            out.append(f"- Owner: {owner}")
        deps = feat.get("deps", [])
        if deps:
            out.append("- Depends on:")
            for d in deps:
                out.append(f"  - {d}")
        # SSoT
        ss = feat.get("ssot", [])
        if ss:
            paths = [s.get("path") for s in ss if s.get("path")]
            out.append("- Single Sources of Truth:")
            for p in paths:
                out.append(f"  - `{p}`")
        # HTTP
        http = feat.get("http", [])
        if http:
            out.append("- HTTP:")
            for h in http:
                out.append(f"  - `{h.get('method','').upper()} {h.get('path','')}`")
        # Read-models
        rms = feat.get("read_models", [])
        if rms:
            out.append("- Read‑models:")
            for r in rms:
                out.append(f"  - `{r}`")
        # Topics (validate)
        tps = feat.get("topics", [])
        if tps:
            out.append("- Events:")
            for t in tps:
                mark = "" if (t in known_topics or t == "state.read.model.patch") else " ⚠"
                out.append(f"  - `{t}`{mark}")
        # Env vars
        envs = feat.get("env", [])
        if envs:
            out.append("- Env:")
            for e in envs:
                out.append(f"  - `{e}`")
        out.append("")
    return "\n".join(out)

def main():
    try:
        features = load_features()
    except Exception as e:
        print(f"error: cannot read features.json: {e}", file=sys.stderr)
        return 2
    known_topics = parse_topics_rs()
    # Path validation
    all_paths = []
    for f in features.get("features", []):
        for s in f.get("ssot", []):
            p = s.get("path")
            if p:
                all_paths.append(p)
    missing = check_paths_exist(all_paths)
    if missing:
        print("warning: missing SSoT paths:\n  - " + "\n  - ".join(missing), file=sys.stderr)
    OUT_MD.parent.mkdir(parents=True, exist_ok=True)
    OUT_MD.write_text(render(features, known_topics), encoding="utf-8")
    print(f"wrote {OUT_MD}")
    return 0

if __name__ == "__main__":
    sys.exit(main())
