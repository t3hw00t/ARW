#!/usr/bin/env python3
"""Generate docs/reference/topics.md from crates/arw-topics/src/lib.rs."""

from __future__ import annotations

import argparse
import datetime as _dt
import pathlib as _pl
import re
import sys
from typing import List, Tuple

ROOT = _pl.Path(__file__).resolve().parents[1]
TOPICS_SRC = ROOT / "crates" / "arw-topics" / "src" / "lib.rs"
DOC_PATH = ROOT / "docs" / "reference" / "topics.md"

CONST_RE = re.compile(r"pub const ([A-Z0-9_]+): &str = \"([^\"]+)\";")
SECTION_RE = re.compile(r"//\s*(.+?)\s*$")
DATE_RE = re.compile(r"^\d{4}-\d{2}-\d{2}$")


class Section:
    __slots__ = ("title", "items")

    def __init__(self, title: str) -> None:
        self.title = title.strip()
        self.items: List[Tuple[str, str]] = []

    def add(self, topic: str, const: str) -> None:
        self.items.append((topic, const))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--check",
        action="store_true",
        help="Verify that the generated markdown matches the on-disk file",
    )
    parser.add_argument(
        "--out",
        type=_pl.Path,
        default=DOC_PATH,
        help="Optional override for the output path (default: docs/reference/topics.md)",
    )
    parser.add_argument(
        "--update-date",
        action="store_true",
        help="Refresh the Updated: stamp to today's date (default keeps the existing value).",
    )
    parser.add_argument(
        "--date",
        type=str,
        help="Explicit YYYY-MM-DD stamp to use for the Updated: header.",
    )
    return parser.parse_args()


def parse_sections() -> List[Section]:
    if not TOPICS_SRC.exists():
        raise SystemExit(f"error: topics source not found: {TOPICS_SRC}")

    sections: List[Section] = []
    current: Section | None = None

    for raw_line in TOPICS_SRC.read_text(encoding="utf-8").splitlines():
        if raw_line.startswith("//!"):
            continue
        match_section = SECTION_RE.match(raw_line)
        if match_section:
            title = match_section.group(1).strip()
            if not title:
                continue
            current = Section(title)
            sections.append(current)
            continue

        match_const = CONST_RE.search(raw_line)
        if match_const:
            const_name, topic = match_const.groups()
            if current is None:
                current = Section("General")
                sections.append(current)
            current.add(topic, const_name)

    # Drop empty sections while preserving order
    return [sec for sec in sections if sec.items]


def read_existing_updated(path: _pl.Path) -> str | None:
    if not path.exists():
        return None
    with path.open("r", encoding="utf-8") as handle:
        for idx, raw_line in enumerate(handle):
            if idx >= 40:
                break
            line = raw_line.strip()
            if line.lower().startswith("updated:"):
                return line.split(":", 1)[1].strip()
    return None


def determine_updated_value(args: argparse.Namespace, existing: str | None) -> str:
    if args.date:
        if not DATE_RE.fullmatch(args.date):
            raise SystemExit(
                f"error: invalid --date value '{args.date}' (expected YYYY-MM-DD)"
            )
        return args.date
    if args.update_date or existing is None:
        return _dt.date.today().isoformat()
    return existing


def render_markdown(sections: List[Section], updated: str) -> str:
    header = f"""---
title: Event Topics (Canonical)
---

# Event Topics (Canonical)
Updated: {updated}
Type: Reference

Source of truth for event kinds published by the service. Generated from
[`crates/arw-topics/src/lib.rs`](https://github.com/t3hw00t/ARW/blob/main/crates/arw-topics/src/lib.rs)
so code and docs stay in sync. Every topic follows dot.case naming; use the
linked source or the Feature Matrix for detailed semantics.

Related docs:
- Explanations → [Events Vocabulary](../architecture/events_vocabulary.md)
- Architecture → [SSE + JSON Patch Contract](../architecture/sse_patch_contract.md)
- How-to → [Subscribe to Events (SSE)](../guide/events_sse.md)
- How-to → [Models Download (HTTP)](../guide/models_download.md)

"""

    lines = [line.rstrip() for line in header.splitlines()]

    for section in sections:
        lines.append(f"## {section.title}")
        lines.append("")
        lines.append("| Topic | Constant |")
        lines.append("|-------|----------|")
        for topic, const_name in section.items:
            lines.append(f"| `{topic}` | `{const_name}` |")
        lines.append("")

    lines.append("<!-- Generated by scripts/gen_topics_doc.py -->")
    lines.append("")
    return "\n".join(lines)


def write_or_check(output_path: _pl.Path, content: str, check_only: bool) -> int:
    if check_only:
        if not output_path.exists():
            print(
                f"error: {output_path} missing (run scripts/gen_topics_doc.py to generate)",
                file=sys.stderr,
            )
            return 1
        current = output_path.read_text(encoding="utf-8")
        if current != content:
            print(
                f"error: {output_path} is out-of-date; re-run scripts/gen_topics_doc.py",
                file=sys.stderr,
            )
            return 1
        return 0

    output_path.write_text(content, encoding="utf-8")
    return 0


def main() -> int:
    args = parse_args()
    sections = parse_sections()
    existing_updated = read_existing_updated(args.out)
    updated_value = determine_updated_value(args, existing_updated)
    markdown = render_markdown(sections, updated_value)
    return write_or_check(args.out, markdown, args.check)


if __name__ == "__main__":
    raise SystemExit(main())
