#!/usr/bin/env python3
import json
import datetime
import pathlib

ROOT = pathlib.Path(__file__).resolve().parents[1]
FEATURES_JSON = ROOT / "interfaces" / "features.json"
CATALOG_JSON = ROOT / "interfaces" / "feature_catalog.json"
OUT_MD = ROOT / "docs" / "reference" / "feature_catalog.md"

def github_blob_base() -> str:
    import subprocess, os, re
    env_base = os.getenv("REPO_BLOB_BASE")
    if env_base:
        return env_base.rstrip('/') + '/'
    try:
        remote = subprocess.check_output(["git", "config", "--get", "remote.origin.url"], text=True).strip()
        m = re.search(r"github\.com[:/]{1,2}([^/]+)/([^/.]+)", remote)
        if m:
            owner, repo = m.group(1), m.group(2)
            return f"https://github.com/{owner}/{repo}/blob/main/"
    except Exception:
        pass
    return "https://github.com/t3hw00t/ARW/blob/main/"


def load_json(path: pathlib.Path):
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def scope_label(scope: dict) -> str:
    parts = [
        scope.get("surface"),
        scope.get("audience"),
        scope.get("layer"),
        scope.get("maturity"),
    ]
    parts = [p for p in parts if p]
    return " / ".join(parts)


def join_backtick(items, limit=None):
    if not items:
        return ""
    seq = [f"`{i}`" for i in items]
    if limit and len(seq) > limit:
        return ", ".join(seq[:limit]) + ", …"
    return ", ".join(seq)


def render_feature(feature: dict) -> str:
    lines = []
    name = feature.get("name", "(unnamed)")
    scope = scope_label(feature.get("scope", {}))
    first = f"- **{name}**"
    if scope:
        first += f" · {scope}"
    lines.append(first)
    desc = feature.get("description")
    if desc:
        lines.append(f"  {desc}")
    http = feature.get("http", [])
    if http:
        http_items = [f"{h.get('method', '').upper()} {h.get('path', '')}" for h in http]
        lines.append(f"  _Routes_: {join_backtick(http_items)}")
    topics = feature.get("topics", [])
    if topics:
        lines.append(f"  _Signals_: {join_backtick(topics)}")
    envs = feature.get("env", [])
    if envs:
        lines.append(f"  _Env_: {join_backtick(envs, limit=8)}")
    ssot = feature.get("ssot", [])
    if ssot:
        base = github_blob_base()
        paths = [entry.get("path") for entry in ssot if entry.get("path")]
        if paths:
            # Link docs paths relatively; code/spec paths to GitHub blob
            items = []
            for p in paths[:3]:
                if p.startswith("docs/"):
                    rel = p[len("docs/"):]
                    # feature_catalog.md lives under docs/reference/
                    items.append(f"[{rel}](../{rel})")
                else:
                    items.append(f"[{p}]({base}{p})")
            if len(paths) > 3:
                items.append("…")
            lines.append("  _Source_: " + ", ".join(items))
    return "\n".join(lines)


def render_catalog(catalog: dict, features: dict) -> str:
    now = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"
    out = []
    out.append("---")
    out.append("title: Universal Feature Catalog")
    out.append("---\n")
    out.append("<!-- generated by scripts/gen_feature_catalog.py; do not edit by hand -->")
    out.append(f"\n_Last updated: {now}_\n")
    out.append("# Universal Feature Catalog\n")
    base = github_blob_base()
    out.append(
        "This catalog maps every shipped capability to the experience pillars we use during the restructure. "
        "It extends the shared language in "
        "[developer/style.md](../developer/style.md) and draws from "
        f"[interfaces/features.json]({base}interfaces/features.json) and "
        f"[interfaces/feature_catalog.json]({base}interfaces/feature_catalog.json)."
    )
    out.append("\n")
    for pillar in catalog.get("pillars", []):
        pname = pillar.get("name", "(pillar)")
        tagline = pillar.get("tagline")
        out.append(f"## {pname}")
        if tagline:
            out.append(tagline)
        out.append("")
        for journey in pillar.get("journeys", []):
            jname = journey.get("name", "(journey)")
            promise = journey.get("promise")
            out.append(f"### {jname}")
            if promise:
                out.append(f"_{promise}_")
            out.append("")
            feats = journey.get("features", [])
            for fid in feats:
                feat = features.get(fid)
                if not feat:
                    continue
                out.append(render_feature(feat))
                out.append("")
        # ensure spacing between pillars
        if not out[-1].strip():
            continue
    return "\n".join(out).rstrip() + "\n"


def main() -> int:
    if not FEATURES_JSON.exists():
        print(f"error: missing {FEATURES_JSON}", flush=True)
        return 2
    if not CATALOG_JSON.exists():
        print(f"error: missing {CATALOG_JSON}", flush=True)
        return 2
    features_doc = load_json(FEATURES_JSON)
    catalog = load_json(CATALOG_JSON)
    features = {f.get("id"): f for f in features_doc.get("features", []) if f.get("id")}
    # Validate catalog references
    missing = []
    for pillar in catalog.get("pillars", []):
        for journey in pillar.get("journeys", []):
            for fid in journey.get("features", []):
                if fid not in features:
                    missing.append(fid)
    if missing:
        missing_sorted = sorted(set(missing))
        raise SystemExit(f"catalog references unknown features: {', '.join(missing_sorted)}")
    OUT_MD.parent.mkdir(parents=True, exist_ok=True)
    OUT_MD.write_text(render_catalog(catalog, features), encoding="utf-8")
    print(f"wrote {OUT_MD}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
